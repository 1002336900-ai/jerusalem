<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×¡×•×“×•×ª ×”×‘×™×¨×”: ×”××ª×’×¨ ×”×™×¨×•×©×œ××™</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Assistant:wght@300;400;700;800&display=swap');

        :root {
            --bg-dark: #062c1b;
            --bg-gradient: #041d12;
            --gold: #f1c40f;
            --stone: #d4a373;
            --modern: #00d2ff;
        }

        body {
            font-family: 'Assistant', sans-serif;
            background-color: var(--bg-dark);
            background-image: radial-gradient(circle at center, var(--bg-dark) 0%, var(--bg-gradient) 100%);
            height: 100vh;
            margin: 0;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://www.transparenttextures.com/patterns/dark-matter.png');
            opacity: 0.2;
            pointer-events: none;
        }

        .shimmer {
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
            background-size: 200% 100%;
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .gate {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border-width: 4px;
            backdrop-filter: blur(10px);
            height: 40vh; /* ×”×’×‘×œ×ª ×’×•×‘×” ×œ×©×¢×¨×™× - ×¤×—×•×ª ××—×¦×™ ×§×™×¨ */
            max-height: 400px;
        }

        .gate-holy { border-color: var(--gold); background: rgba(241, 196, 15, 0.1); box-shadow: 0 0 30px rgba(241, 196, 15, 0.2); }
        .gate-history { border-color: var(--stone); background: rgba(212, 163, 115, 0.1); box-shadow: 0 0 30px rgba(212, 163, 115, 0.2); }
        .gate-modern { border-color: var(--modern); background: rgba(0, 210, 255, 0.1); box-shadow: 0 0 30px rgba(0, 210, 255, 0.2); }

        .gate.hover { transform: scale(1.05); background: rgba(255,255,255,0.15); }

        .site-card {
            position: absolute;
            width: 170px;
            height: 170px;
            cursor: grab;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: white;
            color: #062c1b;
            border-radius: 50%;
            padding: 10px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
            font-weight: 800;
            font-size: 1.1rem;
            border: 6px solid #f8fafc;
            z-index: 10;
        }

        .site-card:active { cursor: grabbing; transform: scale(1.1); }

        .celebration {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(4, 29, 18, 0.95);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(20px, -20px); }
            50% { transform: translate(-15px, 20px); }
            75% { transform: translate(20px, 10px); }
        }

        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .progress-bar {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            width: 60%;
            max-width: 600px;
            margin: 15px auto;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #f1c40f);
            width: 0%;
            transition: width 0.5s ease;
        }

        #instruction-text {
            background: rgba(0,0,0,0.4);
            padding: 10px 30px;
            border-radius: 50px;
            display: inline-block;
            border: 1px solid rgba(241, 196, 15, 0.3);
        }
    </style>
</head>
<body>

    <div class="absolute top-0 w-full text-center py-8 z-50">
        <h1 class="text-5xl font-extrabold text-white mb-3" style="text-shadow: 0 4px 15px rgba(0,0,0,0.9);">×¡×•×“×•×ª ×”×‘×™×¨×”: ×”××ª×’×¨ ×”×™×¨×•×©×œ××™</h1>
        <div id="instruction-text">
            <p class="text-3xl font-bold text-yellow-400">×’×¨×¨×• ××ª ×”××ª×¨ ×œ×§×˜×’×•×¨×™×” ×”××ª××™××”</p>
        </div>
        <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
        </div>
    </div>

    <!-- ×©×¢×¨×™× - ×××•×§××™× ×‘×ª×—×ª×™×ª ×•××•×’×‘×œ×™ ×’×•×‘×” -->
    <div class="flex justify-around items-end w-full h-full pb-10 px-10 gap-8">
        <div id="holy" class="gate gate-holy w-1/4 rounded-t-[3rem] flex flex-col items-center justify-center p-6 text-center">
            <div class="text-6xl mb-2">ğŸ•Œ</div>
            <h2 class="text-3xl font-black text-yellow-400">×§×•×“×© ×•××¡×•×¨×ª</h2>
            <p class="text-base opacity-80 mt-2 text-white">×××•× ×” ×•×§×“×•×©×”</p>
        </div>

        <div id="history" class="gate gate-history w-1/4 rounded-t-[3rem] flex flex-col items-center justify-center p-6 text-center">
            <div class="text-6xl mb-2">ğŸ›¡ï¸</div>
            <h2 class="text-3xl font-black" style="color: #d4a373;">×”×™×¡×˜×•×¨×™×” ×•×’×‘×•×¨×”</h2>
            <p class="text-base opacity-80 mt-2 text-white">×©×•×¨×©×™× ×•××•×¨×©×ª</p>
        </div>

        <div id="modern" class="gate gate-modern w-1/4 rounded-t-[3rem] flex flex-col items-center justify-center p-6 text-center">
            <div class="text-6xl mb-2">ğŸ™ï¸</div>
            <h2 class="text-3xl font-black text-cyan-400">×™×¨×•×©×œ×™× ×”××•×“×¨× ×™×ª</h2>
            <p class="text-base opacity-80 mt-2 text-white">×”×•×•×” ×•×¢×ª×™×“</p>
        </div>
    </div>

    <!-- ××™×–×•×¨ ×”××©×—×§ ×”××¨×›×–×™ -->
    <div id="gameArea" class="fixed inset-0 pointer-events-none"></div>

    <!-- ××¡×š ×¡×™×•× -->
    <div id="celebration" class="celebration">
        <div class="text-[8rem] mb-6">âœ¨ğŸ°âœ¨</div>
        <h2 class="text-6xl font-black text-yellow-400 mb-6">×›×œ ×”×›×‘×•×“, ×©×•××¨×™ ×™×¨×•×©×œ×™×!</h2>
        <p class="text-3xl leading-relaxed text-gray-100 max-w-4xl mb-10">
            ×”×¦×œ×—×ª× ×œ×—×‘×¨ ×‘×™×Ÿ ×”×¢×‘×¨ ×”××¤×•××¨, ×”×§×“×•×©×” ×”×¢××•×§×” ×•×”×¤× ×™× ×”××•×“×¨× ×™×•×ª ×©×œ ×‘×™×¨×ª× ×•. <br>
            ×™×¨×•×©×œ×™× ×”×™× ×¤×¡×™×¤×¡ ×©×œ <strong>×××•× ×”</strong>, <strong>×’×‘×•×¨×”</strong> ×•<strong>×—×™×™× ×ª×•×¡×¡×™×</strong>. <br>
            ×‘×–×›×•×ª×›×, ×”××¤×” ×©×œ ×™×¨×•×©×œ×™× ×©×œ××”!
        </p>
        <button onclick="resetGame()" class="bg-yellow-500 hover:bg-yellow-400 text-green-900 font-black text-3xl py-6 px-16 rounded-full shadow-[0_0_50px_rgba(241,196,15,0.5)] transition transform hover:scale-110 active:scale-95">
            ×”×ª×—×œ ××—×“×©
        </button>
    </div>

    <script>
        const sitesData = [
            { id: 1, name: '×”×›×•×ª×œ ×”××¢×¨×‘×™', cat: 'holy', emoji: 'ğŸ•‹' },
            { id: 2, name: '×× ×”×¨×•×ª ×”×›×•×ª×œ', cat: 'holy', emoji: 'ğŸ”¦' },
            { id: 3, name: '×›× ×¡×™×™×ª ×”×§×‘×¨', cat: 'holy', emoji: 'â›ª' },
            { id: 4, name: '×©×¢×¨ ×”×¨×—××™×', cat: 'holy', emoji: 'â›©ï¸' },
            { id: 5, name: '×’×‘×¢×ª ×”×ª×—××•×©×ª', cat: 'history', emoji: 'ğŸª–' },
            { id: 6, name: '×™×“ ×•×©×', cat: 'history', emoji: 'ğŸ•¯ï¸' },
            { id: 7, name: '×¢×™×¨ ×“×•×“', cat: 'history', emoji: 'ğŸ›ï¸' },
            { id: 8, name: '×©×¢×¨ ×”××¨×™×•×ª', cat: 'history', emoji: 'ğŸ¦' },
            { id: 9, name: '×©×•×§ ××—× ×” ×™×”×•×“×”', cat: 'modern', emoji: 'ğŸ' },
            { id: 10, name: '×”×›× ×¡×ª', cat: 'modern', emoji: 'ğŸ›ï¸' },
            { id: 11, name: '××•×–×™××•×Ÿ ×™×©×¨××œ', cat: 'modern', emoji: 'ğŸ¨' },
            { id: 12, name: '×’×Ÿ ×”×—×™×•×ª ×”×ª× "×›×™', cat: 'modern', emoji: 'ğŸ˜' }
        ];

        let matchedCount = 0;
        const totalSites = sitesData.length;
        const gameArea = document.getElementById('gameArea');
        const gates = document.querySelectorAll('.gate');
        const progressFill = document.getElementById('progressFill');

        function initGame() {
            gameArea.innerHTML = '';
            matchedCount = 0;
            updateProgress();
            document.getElementById('celebration').style.display = 'none';

            sitesData.forEach((site, index) => {
                createSiteCard(site, index);
            });
        }

        function createSiteCard(site, index) {
            const card = document.createElement('div');
            card.className = 'site-card pointer-events-auto';
            card.innerHTML = `<span style="font-size: 3rem; margin-bottom: 5px;">${site.emoji}</span><span>${site.name}</span>`;
            card.id = `site-${site.id}`;
            card.dataset.cat = site.cat;
            
            // ××™×§×•×: ××¨×•×›×– ×™×•×ª×¨ ×‘×—×œ×§ ×”×¢×œ×™×•×Ÿ ×•×”××¨×›×–×™ ×©×œ ×”××¡×š
            // ×¨×•×—×‘: ×‘×™×Ÿ 15% ×œ-85% ××”××¡×š
            // ×’×•×‘×”: ×‘×™×Ÿ 20% ×œ-55% ××”××¡×š (××¢×œ ×”×©×¢×¨×™×)
            const x = (Math.random() * 70 + 15) * (window.innerWidth / 100) - 85;
            const y = (Math.random() * 35 + 20) * (window.innerHeight / 100);
            
            card.style.left = `${x}px`;
            card.style.top = `${y}px`;
            
            card.style.animation = `float ${7 + Math.random() * 4}s ease-in-out infinite`;
            card.style.animationDelay = `${Math.random() * 2}s`;

            addDragListeners(card);
            gameArea.appendChild(card);
        }

        function addDragListeners(el) {
            let isDragging = false;
            let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

            el.addEventListener('touchstart', dragStart, {passive: false});
            el.addEventListener('mousedown', dragStart);

            function dragStart(e) {
                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }

                if (e.target === el || el.contains(e.target)) {
                    isDragging = true;
                    el.style.animation = 'none';
                    el.style.zIndex = 1000;
                    el.style.borderColor = "#2ecc71";
                }
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, {passive: false});
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    let clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                    let clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                    
                    currentX = clientX - initialX;
                    currentY = clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, el);
                    checkGateHover(el);
                }
            }

            function dragEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                el.style.zIndex = 10;
                el.style.borderColor = "#f8fafc";

                const dropTarget = getDropTarget(el);
                
                if (dropTarget && dropTarget.id === el.dataset.cat) {
                    successDrop(el, dropTarget);
                } else {
                    failDrop(el);
                    xOffset = 0; yOffset = 0;
                    setTranslate(0, 0, el);
                }

                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', dragEnd);
                document.removeEventListener('touchend', dragEnd);
            }
        }

        function setTranslate(xPos, yPos, el) {
            el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
        }

        function checkGateHover(el) {
            const rect = el.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            gates.forEach(gate => {
                const gRect = gate.getBoundingClientRect();
                if (centerX > gRect.left && centerX < gRect.right && centerY > gRect.top && centerY < gRect.bottom) {
                    gate.classList.add('hover');
                } else {
                    gate.classList.remove('hover');
                }
            });
        }

        function getDropTarget(el) {
            const rect = el.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let target = null;

            gates.forEach(gate => {
                const gRect = gate.getBoundingClientRect();
                if (centerX > gRect.left && centerX < gRect.right && centerY > gRect.top && centerY < gRect.bottom) {
                    target = gate;
                }
                gate.classList.remove('hover');
            });
            return target;
        }

        function successDrop(el, gate) {
            el.style.pointerEvents = 'none';
            el.style.transition = 'all 0.6s cubic-bezier(0.6, -0.28, 0.735, 0.045)';
            el.style.transform += ' scale(0) rotate(180deg)';
            el.style.opacity = '0';
            
            gate.classList.add('shimmer');
            setTimeout(() => gate.classList.remove('shimmer'), 1000);

            matchedCount++;
            updateProgress();

            if (matchedCount === totalSites) {
                setTimeout(showCelebration, 800);
            }
        }

        function failDrop(el) {
            el.classList.add('shake');
            el.style.borderColor = "#e74c3c";
            setTimeout(() => {
                el.classList.remove('shake');
                el.style.borderColor = "#f8fafc";
                el.style.animation = `float ${7 + Math.random() * 4}s ease-in-out infinite`;
            }, 500);
        }

        function updateProgress() {
            const percentage = (matchedCount / totalSites) * 100;
            progressFill.style.width = `${percentage}%`;
        }

        function showCelebration() {
            document.getElementById('celebration').style.display = 'flex';
        }

        function resetGame() {
            initGame();
        }

        window.onload = initGame;
    </script>
</body>
</html>